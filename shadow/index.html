<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Shadow Simulation</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            touch-action: none; /* Prevent page scroll on touch devices when dragging elements */
            overscroll-behavior: none; /* Prevents pull-to-refresh or other browser gestures when interacting with the simulation */
        }
        .simulation-container {
            width: 95%;
            max-width: 800px;
            height: 65vh; 
            min-height: 380px;
            max-height: 600px;
            background-color: #f0f4f8; 
            border: 2px solid #cbd5e1; 
            position: relative;
            margin: 20px auto;
            overflow: hidden;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        .simulation-container:fullscreen {
            width: 100vw;
            height: 100vh;
            max-width: none;
            max-height: none;
            margin: 0;
            border-radius: 0;
            border: none;
        }

        .draggable {
            position: absolute;
            cursor: grab;
            user-select: none;
            /* Removed border-radius from here as it's not always needed for all draggables */
            display: flex;
            align-items: center;
            justify-content: center;
            /* Removed box-shadow from here, apply individually if needed */
        }
        .draggable:active {
            cursor: grabbing;
            z-index: 100;
        }
        #light-source {
            width: 50px;
            height: 50px;
            background-color: #fef08a; /* Light yellow */
            border: 2px solid #facc15; /* Yellow-400 border */
            border-radius: 50%; /* Circular light source */
            color: #ca8a04; /* Yellow-600 text */
            font-size: 10px;
            text-align: center;
            line-height: 1.2;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        #object-shape {
            width: 60px; /* Base width for the draggable area */
            height: 60px; /* Base height for the draggable area */
            /* REMOVED background-color and border from here to make the container invisible */
            /* background-color: #fda4af; */ /* Rose-300 - REMOVED */
            /* border: 2px solid #f43f5e; */ /* Rose-500 border - REMOVED */
            display: flex;
            align-items: center;
            justify-content: center;
            /* Ensure the SVG is clickable if the parent has no background */
            pointer-events: auto; 
        }
        #object-shape svg {
            width: 100%; /* SVG takes full width of its container */
            height: 100%; /* SVG takes full height of its container */
            fill: #f43f5e; /* Rose-500 - This is the heart color */
            filter: drop-shadow(0 1px 1px rgba(0,0,0,0.2)); /* Add a subtle shadow to the SVG itself */
        }
        #screen-panel {
            width: 30px;
            height: 70%; 
            min-height: 150px;
            background-color: #e2e8f0; /* Slate-200 */
            border: 2px solid #94a3b8; /* Slate-400 border */
            border-radius: 0.375rem; /* Rounded corners for the screen */
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        #shadow-shape {
            position: absolute;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            pointer-events: none; 
        }
        #shadow-shape svg {
            width: 100%;
            height: 100%;
            /* Shadow color is set in JS */
        }
        .light-ray {
            position: absolute;
            border-top: 2px dashed rgba(250, 204, 21, 0.6); /* Yellow-400, semi-transparent */
            transform-origin: 0 0;
            pointer-events: none;
            z-index: 5;
        }
        .info-text {
            font-size: 0.9rem;
            color: #475569; /* Slate-600 */
        }
    </style>
</head>
<body class="bg-slate-100 flex flex-col items-center min-h-screen p-3 sm:p-6">

    <div class="w-full max-w-4xl space-y-4">
        <header class="p-4 sm:p-6 bg-white rounded-xl shadow-xl">
            <p class="text-xs sm:text-sm font-semibold uppercase tracking-[0.3em] text-sky-500 text-center">PSLE Science</p>
            <h1 class="text-2xl sm:text-3xl font-bold text-slate-800 text-center">Shadow Explorer Lab</h1>
            <p class="mt-2 text-sm sm:text-base text-slate-600 text-center">
                Drag the <span class="font-semibold text-yellow-600">Light</span>, the <span class="font-semibold text-rose-500">Object</span>, and the <span class="font-semibold text-slate-500">Screen</span> to see how a shadow changes.
            </p>
        </header>

        <div class="bg-white rounded-xl shadow-lg p-4 sm:p-6">
            <div class="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
                <div class="text-sm text-slate-600">
                    <p class="font-semibold text-slate-700">Choose an object:</p>
                    <div class="mt-2 flex flex-wrap gap-2" id="shape-buttons">
                        <button data-shape="heart" class="shape-btn px-3 py-1.5 rounded-full bg-rose-500 text-white text-sm font-semibold shadow">Heart</button>
                        <button data-shape="star" class="shape-btn px-3 py-1.5 rounded-full bg-amber-400 text-slate-800 text-sm font-semibold shadow-sm">Star</button>
                        <button data-shape="tree" class="shape-btn px-3 py-1.5 rounded-full bg-emerald-500 text-white text-sm font-semibold shadow-sm">Tree</button>
                    </div>
                </div>
                <div class="flex flex-wrap gap-2">
                    <button id="reset-btn" class="px-3 sm:px-4 py-2 bg-slate-200 hover:bg-slate-300 text-slate-700 rounded-md text-sm font-semibold shadow-sm">Reset positions</button>
                    <button id="fullscreen-btn" class="px-3 sm:px-4 py-2 bg-blue-500 hover:bg-blue-600 text-white rounded-md shadow text-sm font-semibold">Fullscreen</button>
                </div>
            </div>
        </div>

        <div id="simulation-area" class="simulation-container">
            <div id="light-source" class="draggable"><span class="block leading-tight">Light</span></div>
            <div id="object-shape" class="draggable">
                <svg viewBox="0 0 24 24">
                  <path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/>
            </svg>
        </div>
        <div id="screen-panel" class="draggable"></div>
        <div id="shadow-shape">
             <svg viewBox="0 0 24 24">
              <path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/>
            </svg>
        </div>
        </div>

        <div class="grid gap-4 lg:grid-cols-2">
            <div class="bg-white rounded-xl shadow-lg p-4 sm:p-5 text-sm sm:text-base" id="measurement-panel">
                <h2 class="text-lg font-semibold text-slate-700 mb-3">Shadow Report</h2>
                <dl class="space-y-3 text-slate-600">
                    <div class="flex items-center justify-between bg-slate-100 rounded-lg px-3 py-2">
                        <dt class="text-xs uppercase tracking-wide text-slate-500">Light → Object</dt>
                        <dd id="light-object-distance" class="font-semibold text-slate-800">-- cm</dd>
                    </div>
                    <div class="flex items-center justify-between bg-slate-100 rounded-lg px-3 py-2">
                        <dt class="text-xs uppercase tracking-wide text-slate-500">Object → Screen</dt>
                        <dd id="object-screen-distance" class="font-semibold text-slate-800">-- cm</dd>
                    </div>
                    <div class="flex items-center justify-between bg-slate-100 rounded-lg px-3 py-2">
                        <dt class="text-xs uppercase tracking-wide text-slate-500">Shadow Size</dt>
                        <dd id="shadow-size" class="font-semibold text-slate-800">-- cm</dd>
                    </div>
                </dl>
            </div>

            <div class="bg-white rounded-xl shadow-lg p-4 sm:p-5 text-sm sm:text-base text-slate-600" id="hint-panel">
                <h2 class="text-lg font-semibold text-slate-700 mb-2">Quick Notes</h2>
                <p id="shadow-tip" class="leading-relaxed">
                    Move the pieces to discover how shadows grow or shrink. Try placing the object close to the light!
                </p>
            </div>
        </div>

        <div class="bg-white rounded-xl shadow-lg p-4 text-xs sm:text-sm text-slate-500">
            <p><span class="font-semibold text-slate-700">Need ideas?</span> Place the light, object, and screen in a straight line. Measure the shadow and see if it is bigger or smaller than the object.</p>
        </div>
    </div>

    <script>
        // Get DOM elements
        const simulationArea = document.getElementById('simulation-area');
        const lightSource = document.getElementById('light-source');
        const objectShape = document.getElementById('object-shape'); // This is the draggable container for the SVG
        let objectSvg = objectShape.querySelector('svg'); // The actual SVG graphic
        const screenPanel = document.getElementById('screen-panel');
        const shadowShape = document.getElementById('shadow-shape');
        let shadowSvg = shadowShape.querySelector('svg');
        const fullscreenBtn = document.getElementById('fullscreen-btn');
        const resetBtn = document.getElementById('reset-btn');
        const shapeButtons = Array.from(document.querySelectorAll('.shape-btn'));
        const lightObjectDistance = document.getElementById('light-object-distance');
        const objectScreenDistance = document.getElementById('object-screen-distance');
        const shadowSize = document.getElementById('shadow-size');
        const shadowTip = document.getElementById('shadow-tip');

        const shapeLibrary = {
            heart: {
                svg: '<svg viewBox="0 0 24 24"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg>'
            },
            star: {
                svg: '<svg viewBox="0 0 24 24"><path d="M12 17.27 18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"/></svg>'
            },
            tree: {
                svg: '<svg viewBox="0 0 24 24"><path d="M12 2c-.9 0-1.63.73-1.63 1.63V6h-2.5c-.68 0-1.23.55-1.23 1.22 0 .3.11.6.31.83l2.42 2.9H6.5c-.69 0-1.25.56-1.25 1.25 0 .35.14.69.4.94l2.6 2.57H7.5c-.83 0-1.5.67-1.5 1.5 0 .38.14.74.4 1.02l3.1 3.3V22h5v-1.87l3.1-3.3c.26-.28.4-.64.4-1.02 0-.83-.67-1.5-1.5-1.5h-1.08l2.6-2.57c.26-.25.4-.59.4-.94 0-.69-.56-1.25-1.25-1.25h-2.87l2.42-2.9c.2-.24.31-.53.31-.83C17.36 6.55 16.81 6 16.13 6h-2.5V3.63C13.63 2.73 12.9 2 12 2Z"/></svg>'
            }
        };

        let currentShape = 'heart';

        // Initial positions: x in px, y as percentage of container height
        let initialPositions = {
            light: { x: 50, y: '50%' },    
            object: { x: 180, y: '50%' }, 
            screen: { x: 350, y: '15%' }   
        };
        
        function setShape(shapeKey) {
            if (!shapeLibrary[shapeKey]) return;
            currentShape = shapeKey;

            objectShape.innerHTML = shapeLibrary[shapeKey].svg;
            shadowShape.innerHTML = shapeLibrary[shapeKey].svg;

            objectSvg = objectShape.querySelector('svg');
            shadowSvg = shadowShape.querySelector('svg');

            const fillColorMap = {
                heart: '#f43f5e',
                star: '#fbbf24',
                tree: '#10b981'
            };

            objectSvg.style.fill = fillColorMap[shapeKey];
            objectSvg.style.filter = 'drop-shadow(0 1px 1px rgba(0,0,0,0.2))';
            shadowSvg.style.fill = '#4b5563';

            shapeButtons.forEach(btn => {
                const isActive = btn.dataset.shape === shapeKey;
                btn.classList.toggle('ring-2', isActive);
                btn.classList.toggle('ring-offset-2', isActive);
                btn.classList.toggle('ring-sky-400', isActive);
                btn.classList.toggle('brightness-110', isActive);
            });

            updateShadowAndRays();
        }
        
        function setInitialPositions() {
            const simHeight = simulationArea.clientHeight;
            const simWidth = simulationArea.clientWidth;

            // Light Source
            const lightX = parseFloat(initialPositions.light.x);
            const lightYPercent = parseFloat(initialPositions.light.y);
            lightSource.style.left = Math.max(0, Math.min(lightX, simWidth - lightSource.offsetWidth - 5)) + 'px';
            let lightCenterY = (lightYPercent / 100) * simHeight;
            lightSource.style.top = Math.max(0, Math.min(lightCenterY - lightSource.offsetHeight / 2, simHeight - lightSource.offsetHeight - 5)) + 'px';

            // Object Shape (draggable container)
            const objectX = parseFloat(initialPositions.object.x);
            const objectYPercent = parseFloat(initialPositions.object.y);
            objectShape.style.left = Math.max(0, Math.min(objectX, simWidth - objectShape.offsetWidth - 5)) + 'px';
            let objectCenterY = (objectYPercent / 100) * simHeight;
            objectShape.style.top = Math.max(0, Math.min(objectCenterY - objectShape.offsetHeight / 2, simHeight - objectShape.offsetHeight - 5)) + 'px';
            
            // Screen Panel
            const screenX = parseFloat(initialPositions.screen.x);
            const screenYPercent = parseFloat(initialPositions.screen.y); 
            screenPanel.style.left = Math.max(0, Math.min(screenX, simWidth - screenPanel.offsetWidth - 5)) + 'px';
            let screenTopY = (screenYPercent / 100) * simHeight;
            // Ensure screen panel's height is correctly accounted for when positioning its top
            screenPanel.style.top = Math.max(0, Math.min(screenTopY, simHeight - screenPanel.offsetHeight - 5)) + 'px';
        }

        function resetSimulation() {
            setInitialPositions();
            updateShadowAndRays();
        }


        // Make elements draggable
        function makeDraggable(element) {
            let isDragging = false;
            let offsetX, offsetY;

            function startDrag(e) {
                isDragging = true;
                element.style.zIndex = 100;
                
                const event = e.touches ? e.touches[0] : e;
                const rect = element.getBoundingClientRect();
                
                offsetX = event.clientX - rect.left;
                offsetY = event.clientY - rect.top;
                
                element.style.cursor = 'grabbing';
                document.body.style.cursor = 'grabbing'; 
            }

            function drag(e) {
                if (!isDragging) return;
                e.preventDefault(); 

                const event = e.touches ? e.touches[0] : e;
                const simRect = simulationArea.getBoundingClientRect();

                let newX = event.clientX - simRect.left - offsetX;
                let newY = event.clientY - simRect.top - offsetY;

                // Constrain within simulation area
                newX = Math.max(0, Math.min(newX, simulationArea.clientWidth - element.offsetWidth));
                newY = Math.max(0, Math.min(newY, simulationArea.clientHeight - element.offsetHeight));

                element.style.left = newX + 'px';
                element.style.top = newY + 'px';
                updateShadowAndRays();
            }

            function stopDrag() {
                if (!isDragging) return;
                isDragging = false;
                element.style.zIndex = '';
                element.style.cursor = 'grab';
                document.body.style.cursor = ''; 
            }

            element.addEventListener('mousedown', startDrag);
            element.addEventListener('touchstart', startDrag, { passive: false });

            document.addEventListener('mousemove', drag);
            document.addEventListener('touchmove', drag, { passive: false }); 
            
            document.addEventListener('mouseup', stopDrag);
            document.addEventListener('touchend', stopDrag);
        }

        makeDraggable(lightSource);
        makeDraggable(objectShape); // The container is draggable
        makeDraggable(screenPanel);

        shapeButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                setShape(btn.dataset.shape);
            });
        });

        resetBtn.addEventListener('click', resetSimulation);

        // Function to create or update a light ray line
        function drawLine(x1, y1, x2, y2, id) {
            let line = document.getElementById(id);
            if (!line) {
                line = document.createElement('div');
                line.id = id;
                line.className = 'light-ray';
                simulationArea.appendChild(line);
            }

            const length = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
            const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;

            line.style.width = length + 'px';
            line.style.transform = `rotate(${angle}deg)`;
            line.style.left = x1 + 'px';
            line.style.top = y1 + 'px';
        }
        
        function removeAllRays() {
            const existingRays = simulationArea.querySelectorAll('.light-ray');
            existingRays.forEach(ray => ray.remove());
        }

        // Function to update shadow and light rays
        function updateShadowAndRays() {
            // Get center positions of elements
            const lightCenterX = lightSource.offsetLeft + lightSource.offsetWidth / 2;
            const lightCenterY = lightSource.offsetTop + lightSource.offsetHeight / 2;

            // Use objectShape (the draggable container) for position, but its dimensions for calculation
            const objContainer = objectShape;
            const objCenterX = objContainer.offsetLeft + objContainer.offsetWidth / 2;
            const objCenterY = objContainer.offsetTop + objContainer.offsetHeight / 2;
            // The actual visual height/width of the heart is from its container (which is sized for the SVG)
            const objActualHeight = objContainer.offsetHeight; 
            const objActualWidth = objContainer.offsetWidth;

            const screenPlaneX = screenPanel.offsetLeft + screenPanel.offsetWidth / 2;

            removeAllRays(); // Clear previous rays

            // Conditions for shadow visibility
            const distLightToObjX = objCenterX - lightCenterX;
            const distLightToScreenX = screenPlaneX - lightCenterX;

            const pxToCm = 0.5; // friendly estimate: 2 px ≈ 1 cm
            if (distLightToObjX > 0) {
                lightObjectDistance.textContent = `${Math.round(distLightToObjX * pxToCm)} cm`;
            } else {
                lightObjectDistance.textContent = '-- cm';
            }

            if (screenPlaneX > objCenterX) {
                objectScreenDistance.textContent = `${Math.max(0, Math.round((screenPlaneX - objCenterX) * pxToCm))} cm`;
            } else {
                objectScreenDistance.textContent = '-- cm';
            }

            // Ensure light is to the left of the object, and object is to the left of the screen
            if (distLightToObjX > 0 && distLightToScreenX > distLightToObjX && lightCenterX < objCenterX && objCenterX < (screenPanel.offsetLeft + screenPanel.offsetWidth)) { 
                shadowShape.style.display = 'flex';
                shadowSvg.style.fill = '#4b5563'; // Gray-600 for shadow color

                const shadowHeight = objActualHeight * (distLightToScreenX / distLightToObjX);
                const shadowWidth = objActualWidth * (distLightToScreenX / distLightToObjX);
                const shadowCenterY = lightCenterY + (objCenterY - lightCenterY) * (distLightToScreenX / distLightToObjX);

                shadowShape.style.height = Math.max(0, shadowHeight) + 'px';
                shadowShape.style.width = Math.max(0, shadowWidth) + 'px';
                shadowShape.style.left = (screenPlaneX - shadowWidth / 2) + 'px';
                shadowShape.style.top = (shadowCenterY - shadowHeight / 2) + 'px';

                const sizeRatio = shadowHeight / objActualHeight;
                let sizeWord = 'same size';
                if (sizeRatio > 1.1) {
                    sizeWord = 'bigger';
                } else if (sizeRatio < 0.9) {
                    sizeWord = 'smaller';
                }

                shadowSize.textContent = `${Math.max(0, Math.round(shadowHeight * pxToCm))} cm (${sizeWord})`;

                const objEdgePointTopY = objContainer.offsetTop; 
                const objEdgePointBottomY = objContainer.offsetTop + objActualHeight;
                
                const shadowTopEdgeY = parseFloat(shadowShape.style.top);
                const shadowBottomEdgeY = shadowTopEdgeY + shadowHeight;

                drawLine(lightCenterX, lightCenterY, objCenterX, objEdgePointTopY, 'ray-top-obj');
                drawLine(objCenterX, objEdgePointTopY, screenPanel.offsetLeft + screenPanel.offsetWidth/2, shadowTopEdgeY, 'ray-top-screen');

                drawLine(lightCenterX, lightCenterY, objCenterX, objEdgePointBottomY, 'ray-bottom-obj');
                drawLine(objCenterX, objEdgePointBottomY, screenPanel.offsetLeft + screenPanel.offsetWidth/2, shadowBottomEdgeY, 'ray-bottom-screen');

                if (sizeRatio > 1.1) {
                    shadowTip.textContent = 'Shadow Alert: The shadow is bigger than the object because the object is closer to the light.';
                } else if (sizeRatio < 0.9) {
                    shadowTip.textContent = 'Shadow Shrink: Moving the object closer to the screen makes the shadow smaller.';
                } else {
                    shadowTip.textContent = 'Perfect match! You lined everything up so the shadow and object are almost the same size.';
                }

            } else {
                shadowShape.style.display = 'none';
                shadowSize.textContent = '-- cm';
                let guidance = 'Line up the light, object, and screen from left to right to make a clear shadow.';
                if (distLightToObjX <= 0) {
                    guidance = 'Move the light to the left of the object so the rays can hit it.';
                } else if (screenPlaneX <= objCenterX) {
                    guidance = 'Slide the screen to the right of the object to catch the shadow.';
                } else if (distLightToScreenX <= distLightToObjX) {
                    guidance = 'Try pulling the screen back a little so the shadow has space to grow.';
                }
                shadowTip.textContent = guidance;
            }
        }
        
        // Fullscreen API Logic
        fullscreenBtn.addEventListener('click', () => {
            if (!document.fullscreenElement) {
                simulationArea.requestFullscreen().catch(err => {
                    console.error(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`);
                });
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        });

        document.addEventListener('fullscreenchange', () => {
            const isFullscreen = !!document.fullscreenElement;
            fullscreenBtn.textContent = isFullscreen ? 'Exit Fullscreen' : 'Fullscreen';
            
            setTimeout(() => {
                // Recalculate screen panel height as it's percentage based
                screenPanel.style.height = '70%'; // Re-apply if needed, or ensure it recalculates based on new parent
                setInitialPositions(); 
                updateShadowAndRays();
            }, 100); 
        });

        // Initialize
        window.addEventListener('load', () => {
            setInitialPositions();
            setShape(currentShape);
            updateShadowAndRays();
        });

        // Update on resize
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                // Recalculate screen panel height as it's percentage based
                screenPanel.style.height = '70%'; // Re-apply if needed
                setInitialPositions(); 
                updateShadowAndRays();
            }, 100); 
        });

    </script>
</body>
</html>
